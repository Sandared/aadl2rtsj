import org.osate.aadl2.NamedElement;
import org.osate.aadl2.instance.ComponentInstance;
import org.osate.aadl2.instance.ConnectionInstance;
import org.osate.aadl2.instance.FeatureInstance;
import org.osate.aadl2.instance.InstanceObject;

import static de.uniaugsburg.smds.aadl2rtsj.utils.Utils.*;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CLASS{
	
	private static String getImportStatements(List<InstanceObject> objects){
		StringBuilder sb = new StringBuilder();
		if(objects.size() != 0){
			ImportStatement statement = new ImportStatement();
			for (InstanceObject object : objects) {
				sb.append(statement.generate(object));
			}
		}
		return sb.toString().trim();
	}
	
	private static String getAssignmentStatements(List<InstanceObject> objects){
		StringBuilder sb = new StringBuilder();
		List<ConnectionInstance> connections = new ArrayList<ConnectionInstance>();
		List<InstanceObject> componentsAndFeatures = new ArrayList<InstanceObject>();
		
		// we need to give each object a unique name
		// as full qualified names might be unreadable, we just name them connection_X, feature_X, component_X
		long connectionCounter = 0;
		long featureCounter = 0;
		long componentCounter = 0;
		
		// now we have to remeber which object received which number
		Map<InstanceObject, String> names = new HashMap<InstanceObject, String>(); 
		
		// objects are collected top-down, but we have to create them bottom-up, so that each constructor's parameters are created before they are assigned
		Collections.reverse(objects);
		
		// connections are treated differently, so sort them into distinct lists
		for (InstanceObject object : objects) {
			if(object instanceof ConnectionInstance)
				connections.add((ConnectionInstance)object);
			if(object instanceof FeatureInstance)
				componentsAndFeatures.add(object);
			if(object instanceof ComponentInstance)
				componentsAndFeatures.add(object);
		}
		
		// do connections first, as they have parameterless constructors
		MainConnectionStatement connnectionStatement = new MainConnectionStatement();
		for (ConnectionInstance connection : connections) {
			sb.append(connnectionStatement.generate(connection, connectionCounter));
			names.put(connection, "connection_" + connectionCounter);
			connectionCounter++;
		}
		
		MainFeatureStatement featureStatement = new MainFeatureStatement();
		MainComponentStatement componentStatement = new MainComponentStatement();
		
		//now we can create the other statements bottom-up
		for (InstanceObject object : componentsAndFeatures) {
			// we have to decide between features and components, because features can only have connection parameters, 
			// whereas components can have feature and/or component parameters
			if(object instanceof FeatureInstance){
				sb.append(featureStatement.generate((FeatureInstance)object, featureCounter, names));
				names.put(object, "feature_" + featureCounter);
				featureCounter++;
			}
			else{
				// must be a ComponentInstance
				sb.append(componentStatement.generate((ComponentInstance)object, componentCounter, names));
				names.put(object, "component_" + componentCounter);
				componentCounter++;
			}
		}
		return sb.toString().trim();
	}
	
	/*
	 * (non-javadoc)
	 * 
	 * @see IGenerator#generate(Object)
	 */
	public String generate(List<InstanceObject> objects) {
		return "";
	}
}