import java.util.List;
import java.util.logging.Logger;

import org.osate.aadl2.instance.InstanceObject;

import org.osate.aadl2.instance.FeatureInstance;
import static de.uniaugsburg.smds.aadl2rtsj.utils.Utils.*;
import static de.uniaugsburg.smds.aadl2rtsj.utils.Constants.*;

import org.osate.aadl2.AbstractNamedValue;
import org.osate.aadl2.BasicPropertyAssociation;
import org.osate.aadl2.Classifier;
import org.osate.aadl2.DirectionType;
import org.osate.aadl2.Element;
import org.osate.aadl2.EnumerationLiteral;
import org.osate.aadl2.Feature;
import org.osate.aadl2.FeatureClassifier;
import org.osate.aadl2.IntegerLiteral;
import org.osate.aadl2.NamedElement;
import org.osate.aadl2.NamedValue;
import org.osate.aadl2.PropertyExpression;
import org.osate.aadl2.RecordValue;
import org.osate.aadl2.UnitLiteral;
import org.osate.aadl2.instance.ComponentInstance;
import org.osate.aadl2.instance.ConnectionInstance;

public class CLASS{
	
	private static final Logger log = Logger.getLogger( PeriodicThreadConverter.class.getName() );
	
	private static String getSubcomponentImportStatements(ComponentInstance component){
		List<ComponentInstance> subcomponents = component.getAllComponentInstances();
		if(subcomponents.size() > 1){
			StringBuilder sb = new StringBuilder();
			sb.append("/*\n");
			sb.append("* IMPORT SUBCOMPONENTS\n");
			sb.append("*/\n");
			//skip the first one as it is the component itself
			for(int i = 1; i < subcomponents.size(); i++){
				sb.append(new ImportStatement().generate(subcomponents.get(i)));
			}
			return sb.toString();
		}
		else{
			return "";
		}
	}
	
	private static String getSubcomponentMemberStatements(ComponentInstance component){
		List<ComponentInstance> subcomponents = component.getAllComponentInstances();
		if(subcomponents.size() > 1){
			StringBuilder sb = new StringBuilder();
			sb.append("\t/*\n");
			sb.append("\t* SUBCOMPONENTS\n");
			sb.append("\t*/\n");
			//skip the first one as it is the component itself
			for(int i = 1; i < subcomponents.size(); i++){
				sb.append(new MemberStatement().generate(subcomponents.get(i)));
			}
			return sb.toString();
		}
		else{
			return "";
		}
	}
	
	private static String getFeatureMemberStatements(ComponentInstance component){
		List<FeatureInstance> features = component.getAllFeatureInstances();
		if(features.size() > 0){
			StringBuilder sb = new StringBuilder();
			sb.append("\t/*\n");
			sb.append("\t* FEATURES\n");
			sb.append("\t*/\n");
			for(int i = 0; i < features.size(); i++){
				sb.append(new MemberStatement().generate(features.get(i)));
			}
			return sb.toString().trim();
		}
		else{
			return "";
		}
	}
	
	private static String getDispatchStatements(ComponentInstance component){
		return getStatementsForReferenceTime(component, Communication_Properties_IO_Reference_Time_Dispatch);
	}
	
	private static String getStartStatements(ComponentInstance component){
		return getStatementsForReferenceTime(component, Communication_Properties_IO_Reference_Time_Start);
	}
	
	private static String getCompletionStatements(ComponentInstance component){
		return getStatementsForReferenceTime(component, Communication_Properties_IO_Reference_Time_Completion);
	}
	
	private static String getDeadlineStatements(ComponentInstance component){
		return getStatementsForReferenceTime(component, Communication_Properties_IO_Reference_Time_Deadline);
	}
	
	private static String getStatementsForReferenceTime(ComponentInstance component, final String IOReferenceTime){
		List<FeatureInstance> features = component.getAllFeatureInstances();
		// only do something if features are defined
		if(features.size() > 0){
			StringBuilder sb = new StringBuilder();
			for (FeatureInstance feature : features) {
				switch (feature.getCategory()) {
					case DATA_PORT:
						getDataPortStatementsForReferenceTime(feature, sb, IOReferenceTime);
						break;
					case EVENT_PORT:
						// TODO: Event Port Statements
						break;
					case EVENT_DATA_PORT:
						// TODO: Event Data Port Statements
						break;
					default:
						log.info("some other feature than ports");
						break;
					}
			}
			return sb.toString().trim();
		}
		return "";
	}


	
	private static void getDataPortStatementsForReferenceTime(FeatureInstance feature, StringBuilder sb, final String IOReferenceTime){
		// which direction is the feature? in, out, inout
		DirectionType direction = feature.getDirection();
		
		if(direction.incoming()){
			// get all connections, where this feature is the destination
			List<ConnectionInstance> ingoingConnections = feature.getDstConnectionInstances();
			String inputAt = null;
			
			// if immediate/delayed connections are present, then ignore Input_Time
			if(ingoingConnections.size() > 0){
				// in DataPorts may have only one connection per mode. We don't consider modes at the moment, so there may only be one connection. 
				ConnectionInstance connection = ingoingConnections.get(0);
				inputAt = getInputTimeForConnection(connection);
			}
			
			// if NOT immediate/delayed consider Time part of Input_Time and IGNORE offset
			if(inputAt == null)
               inputAt = getInputTimeForReferenceTime(feature, IOReferenceTime);
            else{
        	   // if there has been not Input_Time on the feature, check for Input_Time on thread, see AADL Standard 8.3.2 (18)
        	   ComponentInstance component = feature.getContainingComponentInstance();
        	   inputAt = getInputTimeForReferenceTime(component, IOReferenceTime);
            }
			
			//if inputAt is still null, then default is Dispatch, see AADL Standard 8.3.2 (17)). 
			if(inputAt == null)
				inputAt = Communication_Properties_IO_Reference_Time_Dispatch;
			//if inputAt is NoIO, then nothing happens, see AADL Standard 8.3.2 (19)
			if(inputAt.equals(IOReferenceTime)){
				//freeze input
				sb.append(new ReceiveInputStatement().generate(feature));// see AADL Standard 8.3.2 (21)
			}
		}
		
		// an Output_Time with Dispatch is not valid so we don't need to consider those
		if(IOReferenceTime.equals(Communication_Properties_IO_Reference_Time_Dispatch))
			return;
		
		if(direction.outgoing()){
			// TODO: special treatment?
		}
	}
	
	private static String getInputTimeForConnection(ConnectionInstance connection){
		List<PropertyExpression> timingProperties = connection.getPropertyValues(Communication_Properties, Communication_Properties_Timing);
		String inputAt = null;
		if(timingProperties.size() > 0){
			EnumerationLiteral timingProperty = (EnumerationLiteral)((NamedValue)timingProperties.get(0)).getNamedValue();
			String timing = timingProperty.getName(); // sampled, immediate, delayed
			if(timing.equals(Communication_Properties_Timing_Immediate))
				inputAt = Communication_Properties_IO_Reference_Time_Start; // see AADL Standard 9.2.5 (50)
			if(timing.equals(Communication_Properties_Timing_Delayed))
				inputAt = Communication_Properties_IO_Reference_Time_Dispatch;// see AADL Standard 9.2.5 (51)
			// sampled has no special semantic meaning for input and output timing
		}
		return inputAt;
	}
	
	private static String getInputTimeForReferenceTime(NamedElement element, final String IOReferenceTime){
		List<PropertyExpression> inputTimeProperties = element.getPropertyValues(Communication_Properties, Communication_Properties_Input_Time);
		String inputAt = null;
        if(inputTimeProperties.size() > 0){
     	   // Input_Time might be a list, so Input can be frozen multiple times during a dispatch, see AADL Standard 8.3.2 (20)
     	   for (PropertyExpression inputTimeProperty : inputTimeProperties) {
     		   // Input_Time consists of a Time Part, which is an EnumerationLiteral and an Offset, which is a RangeValue
     		   // we ignor Offset and are only interested in the Time part (Dispatch, Start, Completion, Deadline, NoIO)
     		   NamedValue timePart = (NamedValue)((RecordValue)inputTimeProperty).getOwnedFieldValues().get(0).getOwnedValue();
     		   inputAt = ((EnumerationLiteral)timePart.getNamedValue()).getName();
     		   if(inputAt.equals(IOReferenceTime)){
     			   break;
     		   }
     	   }
        }
        return inputAt;
	}
	
	/*
	 * (non-javadoc)
	 * 
	 * @see IGenerator#generate(Object)
	 */
	public String generate(ComponentInstance component) {
		return "";
	}
}