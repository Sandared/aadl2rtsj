[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate.
 */]
[module PeriodicThreadGenerator('http://aadl.info/AADL/2.0', 'http://aadl.info/AADL/2.0/instance', 'http://www.uniaugsburg.de/smds/aadl2rtsj/generation/util')]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::common::CommonHelper /]


[template public generatePeriodicThread(thread : ComponentInstance)? (isPeriodic(thread)) ]
[file(getPackageName(thread).substitute('.', '/').concat('/').concat(getClassName(thread)).concat('.java') , false, 'UTF-8')]
package [getPackageName(thread)/];

import javax.realtime.Timer;
import javax.realtime.OneShotTimer;
import javax.realtime.RelativeTime;
import javax.realtime.PeriodicTimer;
[comment if this thread has a immediate connection where it is the target, it has to wait and therefore needs to be a BoundAsyncEventHandler. Otherwise it's just an AsyncEventHandler /]
import javax.realtime.[getHandlerType(thread)/];
import javax.realtime.PriorityParameters;

[comment Create an Import Statement for each Subcomponent, Features are in the same package and don't need an Import Statement /]
[for (subcomponent : ComponentInstance | getSubcomponents(thread))]
import [getPackageName(subcomponent)/].[getClassName(subcomponent)/];
[/for]

[comment if this thread has an immediate connection where it is the target, it has to wait and therefore needs to be a BoundAsyncEventHandler. Otherwise it's just an AsyncEventHandler /]

public class [getClassName(thread)/] extends [getHandlerType(thread)/]{
	private Timer timer;
	[comment Create a Member Statement for each Subcomponent /]
	[for (subcomponent : ComponentInstance | getSubcomponents(thread))]
	private [getClassName(subcomponent)/] [getObjectName(subcomponent)/];
	[/for]
	[comment Create a Member Statement for each Feature/]
	[for (feature : FeatureInstance | getFeatures(thread))]
	private [getClassName(feature)/] [getObjectName(feature)/];
	[/for]
	[comment consider possible Member Statement for Synchronisation Object/]
	[let connection : ConnectionInstance = getImmediateConnection(thread)]
	private Object [getSynchronisationObjectName(connection)/];
	[/let]	

	public [getClassName(thread)/]([getConstructorParameters(thread)/]){
		super();
		setDaemon(false);
		setSchedulingParameters(new PriorityParameters([getPriority(thread)/]));
		timer = new PeriodicTimer(new RelativeTime(), new RelativeTime([getPeriodMilliSeconds(thread)/], [getPeriodNanoSeconds(thread)/]), this);
		
		[comment for each feature we have to create an Assignment Statement/]
		[for (feature : FeatureInstance | getFeatures(thread))]
		this.[getObjectName(feature)/] = [getObjectName(feature)/];
		[/for]

		[comment for each subcomponent we have to create an Assignment Statement/]
		[if (getSubcomponents(thread)->size() > 0)]
			[for (subcomponent : ComponentInstance | getSubcomponents(thread))]
				[if (i > 1)]
		this.[getObjectName(subcomponent)/] = [getObjectName(subcomponent)/];
				[/if]
			[/for]
		[/if]
		
		[comment consider possible synchronisationobjects/]
		[comment TODO: what if there are multiple immediate connections for this CI?/]
		[let connection : ConnectionInstance = getImmediateConnection(thread)]
		this.[getSynchronisationObjectName(connection)/] = [getSynchronisationObjectName(connection)/];
		[/let]		
	}
	
	@Override
	public void handleAsyncEvent() {
		[comment add a wait statement if we have to /]
		[let connection : ConnectionInstance = getImmediateConnection(thread)]
			[comment we do this only if we are the target, which has to wait/]
			[if (getComponentInstance(connection.destination) = thread)]
		synchronized([getSynchronisationObjectName(connection)/]){
			try{
				// TODO: not yet sure how to solve synchronization for immediate connections 
				//while(![getObjectName(connection)/].isDirty()){
					[getSynchronisationObjectName(connection)/].wait();
				//}
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
			[/if]
		[/let]	
		dispatch();
		start();
		compute();
		completion();
	}
	
	private final void dispatch() {
		[getStatementsForReferenceTime(thread, getProperty('Communication_Properties_IO_Reference_Time_Dispatch'))/]
		[comment we need deadline statements at this point, as there is no way to hook into the JVM to listen for a deadline /]
		[getStatementsForReferenceTime(thread, getProperty('Communication_Properties_IO_Reference_Time_Deadline'))/]
	}
	
	private final void start() {
		[getStatementsForReferenceTime(thread, getProperty('Communication_Properties_IO_Reference_Time_Start'))/]
	}
	
	private final void compute() {
		System.out.println("[getPackageName(thread)/].[getClassName(thread)/].compute()");
	}
	
	private final void completion() {
		[getStatementsForReferenceTime(thread, getProperty('Communication_Properties_IO_Reference_Time_Completion'))/]
	}
	
	/**
	 * Starts the execution of this object
	 */
	public void startExecution(){
		timer.start();
	}
	
	/**
	 * Stops the execution of this object
	 */
	public void stopExcution(){
		timer.stop();
	}
}
[/file]
[/template]

[template private getHandlerType(thread : ComponentInstance) post (trim()) {connection : ConnectionInstance = getImmediateConnection(thread);}]
	[if ((connection <> null) and (getComponentInstance(getConnectionDestination(connection)) = thread))]
		BoundAsyncEventHandler
	[else]
		AsyncEventHandler
	[/if]
[/template]

[template private getConstructorParameters(thread : ComponentInstance) post (replaceAll('\n', '').trim()) {connection : ConnectionInstance = getImmediateConnection(thread);}]
	[for (feature : FeatureInstance | getFeatures(thread)) separator (', ')]
[getClassName(feature)/] [getObjectName(feature)/]
	[/for]
	[if (getSubcomponents(thread)->size() > 0)]
, 
	[/if]
	[for (subcomponent : ComponentInstance | getSubcomponents(thread)) separator (', ')]
[getClassName(subcomponent)/] [getObjectName(subcomponent)/]
	[/for]
	[if (connection <> null)]
, Object [getSynchronisationObjectName(connection)/]
	[/if]
[/template]

[template public getStatementsForReferenceTime(thread : ComponentInstance, IOReferenceTime : String)post (trim())]
	[for (feature : FeatureInstance | getFeatures(thread))]
		[if (isDataPort(feature))]
			[if (isIncoming(feature))]
				[comment IGNORE Input_Time == Deadline, it seems to be forbidden by standard 8.3.2 (19) TODO: ask on mailinglist for clarification /]
				[if (IOReferenceTime <> getProperty('Communication_Properties_IO_Reference_Time_Deadline'))]
[getDataPortInputStatementsForReferenceTime(feature, IOReferenceTime)/]
				[/if]
			[/if]
			[if (isOutgoing(feature))]
				[comment IGNORE Output_Time == Dispatch, it seems to be forbidden by standard 8.3.2 (27) TODO: ask on mailinglist for clarification/]
				[if (IOReferenceTime <> getProperty('Communication_Properties_IO_Reference_Time_Dispatch'))]
[getDataPortOutputStatementsForReferenceTime(feature, IOReferenceTime)/]
				[/if]
			[/if]
		[/if]
	[/for]
[/template]

[comment ASSUMPTIONS/] 
[comment (1) IGNORE Input_Rate/]
[comment (2) IGNORE negative Offset part of Timing/]
[template private getDataPortInputStatementsForReferenceTime(feature : FeatureInstance, IOReferenceTime : String)]
	[comment get all connections, where this feature is the destination/]
	[comment if immediate/delayed connections are present, then ignore Input_Time/]
	[for (connection : ConnectionInstance | getDstConnectionInstances(feature))]
		[comment in DataPorts may have only one connection per mode. We don't consider modes at the moment, so there may only be one connection/]
		[comment determine actual timing for this feature-connection-combination/] 
		[for (offsetTime : OffsetTime | getTimes(feature, connection, IOReferenceTime, true))]
			[comment as we don't consider modes, we could only take the first one/]
			[comment if outputAt is NoIO, then nothing happens, see AADL Standard 8.3.2 (19)/]
			[if(offsetTime.ioTime = IOReferenceTime)]
				[if (offsetTime.ms = 0 and offsetTime.ns = 0)]
					[comment freeze input via simple statement/]
[getObjectName(feature)/].receiveInput();
				[else]
					[comment we need to generate a statement for handling via handler/]
Timer timerFor[getHandlerClassName(feature, offsetTime)/] = new OneShotTimer(new RelativeTime([offsetTime.ms/], [offsetTime.ns/]), new [getHandlerClassName(feature, offsetTime)/]([getObjectName(feature)/]));
timerFor[getHandlerClassName(feature, offsetTime)/].start();
				[/if]
			[/if]
		[/for]
	[/for]
[/template]

[comment ASSUMPTIONS/]
[comment (1) IGNORE Output_Rate/]
[comment (2) IGNORE negative Offset part of Timing/]
[template private getDataPortOutputStatementsForReferenceTime(feature : FeatureInstance, IOReferenceTime : String)]
	[comment get all connections, where this feature is the source/]
	[comment if immediate/delayed connections are present, then partially ignore Output_Time/]
	[for (connection : ConnectionInstance | getSrcConnectionInstances(feature))]
		[comment out DataPorts may have multiple connections per mode/] 
		[comment those might have different timings/]
		[comment determine actual timing for this feature-connection-combination/] 
		[for (offsetTime : OffsetTime | getTimes(feature, connection, IOReferenceTime, false))]
			[comment if outputAt is NoIO, then nothing happens, see AADL Standard 8.3.2 (19)/]
			[if(offsetTime.ioTime = IOReferenceTime)]
				[comment deadline must be treated different, as it is always done by a handler/]
				[if(IOReferenceTime = getProperty('Communication_Properties_IO_Reference_Time_Deadline'))]
Timer timerFor[getHandlerClassName(feature, offsetTime)/] = new OneShotTimer(timer.getFireTime(), new [getHandlerClassName(feature, offsetTime)/]([getObjectName(feature)/]));
timerFor[getHandlerClassName(feature, offsetTime)/].start();
				[elseif ((offsetTime.ms = 0) and (offsetTime.ns = 0))]
					[comment send output, but only for this specific connection via simple statement/]
					[comment see AADL Standard 8.3.2 (29)/]
[getObjectName(feature)/].sendOutputOn[getClassName(connection)/]();
				[else]
					[comment we need to generate a statement for handling via handler/]
Timer timerFor[getHandlerClassName(feature, offsetTime)/] = new OneShotTimer(new RelativeTime([offsetTime.ms/], [offsetTime.ns/]), new [getHandlerClassName(feature, offsetTime)/]([getObjectName(feature)/]));
timerFor[getHandlerClassName(feature, offsetTime)/].start();
				[/if]
			[/if]
		[/for]
	[/for]
[/template]
