[comment encoding = UTF-8 /]
[module OutDataPortGenerator('http://aadl.info/AADL/2.0', 'http://aadl.info/AADL/2.0/instance')]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ComponentClassifierHelper /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ComponentInstanceHelper /]

[template public generateOutDataPort(dataPort : FeatureInstance)? (isOutgoing(dataPort)) { classifier : ComponentClassifier = getClassifier(dataPort); } ]
[file(getPackageName(dataPort).substitute('.', '/').concat('/').concat(getClassName(dataPort)).concat('.java') , false, 'UTF-8')]
package [getPackageName(dataPort)/];

[comment if it is a base type, then we don't have to import anything, as Integer, Boolean etc are part of java.lang/]
[if ((classifier <> null) and not isBaseType(classifier))]
import [getPackageName(classifier)/].[getClassName(classifier)/];
[/if]

[comment for all connections we have to create an import statement/]
[for (connection : ConnectionInstance | getSrcConnectionInstances(dataPort))]
import [getPackageName(connection)/].[getClassName(connection)/];
[/for]

public class [getClassName(dataPort)/]{
	
	private [getDataType(dataPort)/] value = null;

	[comment for all connections we have to create a member declaration statement/]
	[for (connection : ConnectionInstance | getSrcConnectionInstances(dataPort))]
	private [getClassName(connection)/] [getObjectName(connection)/];
		[comment consider synchronisationObjects /]
		[if (isImmediate(connection))]
	private Object [getSynchronisationObjectName(connection)/];
		[/if]
		
	[/for]
		
	public [getClassName(dataPort)/]([getConstructorParameters(dataPort)/]){
	[for (connection : ConnectionInstance | getSrcConnectionInstances(dataPort))]
		[comment for each connection we have to create an assignment/]
		this.[getObjectName(connection)/] = [getObjectName(connection)/];
		[if (isImmediate(connection))]
		this.[getSynchronisationObjectName(connection)/] = [getSynchronisationObjectName(connection)/];
		[/if]
	[/for]
	}
	
	/**
	 * This method stores the given value and everytime a <code>sendOutputOnXXX()</code> occurs,<br>
	 * then this value is written to the respective connection
	 * @param the value that shall be written to a connection, the next time <code>sendOuntuptOnXXX()</code> is called
	 */
	public void putValue([getDataType(dataPort)/] value){
		this.value = value;
	}
	
	[for (connection : ConnectionInstance | getSrcConnectionInstances(dataPort))]
	/**
	 * Sends the currently available value to connection <code><%=getObjectName(connection)%></code><br>
	 * The value has to be made available by calling <code>putValue()</code> before
	 */
	public void sendOutputOn[getClassName(connection)/](){
		[getObjectName(connection)/].putValue(value);
		[if (isImmediate(connection))]
		synchronized([getSynchronisationObjectName(connection)/]){
			[getSynchronisationObjectName(connection)/].notifyAll();
		}
		[/if]
	}
	[/for]
}

[/file]

[/template]

[comment for each connection we have to create a parameter /]
[template private getConstructorParameters(dataPort : FeatureInstance) post (replaceAll('\n', '').trim())]
	[for (connection : ConnectionInstance | getSrcConnectionInstances(dataPort)) separator (', ')]
[getClassName(connection)/] [getObjectName(connection)/] [if (isImmediate(connection))], Object [getSynchronisationObjectName(connection)/]	[/if]
	[/for]
[/template]