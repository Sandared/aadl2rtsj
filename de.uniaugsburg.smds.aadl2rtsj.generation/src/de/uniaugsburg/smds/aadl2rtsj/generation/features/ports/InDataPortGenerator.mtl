[comment encoding = UTF-8 /]
[module InDataPortGenerator('http://aadl.info/AADL/2.0', 'http://aadl.info/AADL/2.0/instance')]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::common::CommonHelper /]

[template public generateInDataPort(dataPort : FeatureInstance)? (isIncoming(dataPort)) { classifier : Classifier = getClassifier(dataPort); } ]
[file(getPackageName(dataPort).substitute('.', '/').concat('/').concat(getClassName(dataPort)).concat('.java') , false, 'UTF-8')]
package [getPackageName(dataPort)/];

[comment  if it is a base type, then we don't have to import anything, as Integer, Boolean etc are part of java.lang. If it is null, we use Object and therefore have nothing to import either/]
[if ((classifier <> null)and not isBaseType(classifier))]
import [getPackageName(classifier)/].[getClassName(classifier)/];
[/if]
[comment for all connections we have to create an import statement. actually this should only be one, as we don't consider modes /]
[for (connection : ConnectionInstance | getDstConnectionInstances(dataPort))]
import [getPackageName(connection)/].[getClassName(connection)/];
[/for]

public class [getClassName(dataPort)/]{
	
	private [getDataType(dataPort)/] value = null;
	private boolean isNew = false;
	[comment for all connections we have to create an declaration statement. actually this should only be one, as we don't consider modes /]	
	[for (connection : ConnectionInstance | getDstConnectionInstances(dataPort))]
	private [getClassName(connection)/] [getObjectName(connection)/];
	[/for]
	
	public [getClassName(dataPort)/]([getConstructorParameters(dataPort)/]){
		[for (connection : ConnectionInstance | getDstConnectionInstances(dataPort))]
		this.[getObjectName(connection)/] = [getObjectName(connection)/];
		[/for]
	}


	
	/**
	 * This method returns the data that was made available by calling <code>receiveInput()</code><br>
	 * If there has been no call to <code>receiveInput()</code> since the last call, then the old value <br>
	 * of this data port is returned
	 * @return the currently available data for this port
	 */
	public [getDataType(dataPort)/] getValue(){
		isNew = false;
		return value;
	}

	[comment for all connections we have to create an import statement. actually this should only be one, as we don't consider modes nor data aggregation /]
	[for (connection : ConnectionInstance | getDstConnectionInstances(dataPort)) separator ('\n\n')]
	/**
	 * Freezes the currently available input on this Data Port.<br>
	 * Afterwards the frozen value can be retrieved by calling <code>getValue()</code>
	 */
	public void receiveInput(){
		value = [getObjectName(connection)/].getValue();
		isNew = true;
	}
	[/for]
	
	/**
	 * As a Data Port only can have one data at one time, a return value of 1<br>
	 * can be considered as "new data available", as well as a return value of 0 can be considered as <br>
	 * "no new data available"
	 * @return number of data received at this port since the last call to <code>getValue()</code>
	 */
	public int getCount(){
		return (isNew)? 1:0;
	}
}
[/file]

[/template]

[comment for each connection we have to create a parameter /]
[template private getConstructorParameters(dataPort : FeatureInstance) post (replaceAll('\n', '').trim())]
	[for (connection : ConnectionInstance | getDstConnectionInstances(dataPort)) separator (', ')]
[getClassName(connection)/] [getObjectName(connection)/]
	[/for]
[/template]

