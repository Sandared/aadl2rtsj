[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate.
 */]
[module PeriodicThreadGenerator('http://aadl.info/AADL/2.0', 'http://aadl.info/AADL/2.0/instance', 'http://www.uniaugsburg.de/smds/aadl2rtsj/generation/util')]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ComponentInstanceHelper /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ComponentClassifierHelper /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::util::InnerConnectionBrokerGenerator /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::PropertyHelper /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::user::ThreadUserCodeGenerator /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::instance::util::InstanceHelper /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::LogHelper /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::util::IOHandlerGenerator /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ThreadHelper /]

[template public generatePeriodicThread(thread : ComponentInstance)? (thread.getDispatchProtocol() = getProperty('Thread_Properties_Dispatch_Protocol_Periodic')) { classifier : ComponentClassifier = thread.getClassifier(); parentClassifier : ComponentImplementation = thread.getParent().getClassifier().oclAsType(ComponentImplementation) ;}]

[comment generate Connection Broker for this thread /]
[thread.generateInnerConnectionBroker()/]

[comment generate IOHandler if necessary /]
[comment BUG if we put the generation of the handler classes into their own templates then Acceleo completly wents nuts and does some crazy stuff... don't know why /]
[for (dataPort : DataPort | classifier.getAllFeatures()->select(oclIsTypeOf(DataPort)))]
	[comment we have to initialize the variable featureClassifier here, because Acceleo currently has problems with the scoping of variables. If a template is called with a query as parameter this query leads to wrong parameters for the template/]
	[let featureClassifier : ComponentClassifier = dataPort.getClassifier()]
		[for (time : OffsetTime | dataPort.getTimes(parentClassifier))]
			[comment only do something if there is an offset or if it is at deadline, at deadline we always have to use handlers/]
			[if ((time.ioTime = getProperty('Communication_Properties_IO_Reference_Time_Deadline')) or (time.ms <> 0 or time.ns <> 0))]
				[info(time.ioTime + ' : ' + time.ms + '/' + time.ns)/]
				[info('THREAD : ' + thread)/]
				[if (dataPort.isIncoming())]
					[thread.generateInputHandler(featureClassifier, time)/]
				[/if]
				[if (dataPort.isOutgoing())]
					[thread.generateOutputHandler(featureClassifier, time)/]
				[/if]
			[/if]
		[/for]
	[else]
		[warning('No ComponentClassifier found for : ' + dataPort + '. Could not generate handler!')/]
	[/let]
[/for]

[comment generate Usercode class for this thread /]
[generateUserCode(thread)/]

[file(thread.getFileName() , false, 'UTF-8')]
package [thread.getPackageName()/];

import javax.realtime.Timer;
import javax.realtime.OneShotTimer;
import javax.realtime.RelativeTime;
import javax.realtime.PeriodicTimer;
[comment if this thread has an immediate connection where it is the target, it has to wait and therefore needs to be a BoundAsyncEventHandler. Otherwise it's just an AsyncEventHandler /]
import javax.realtime.[thread.getHandlerType()/];
import javax.realtime.PriorityParameters;

//########## Classifier Imports ##########
	[comment import all classifiers of this ThreadImplementation, but only once for each classifier/]
	[for (classifier : ComponentClassifier | classifier.oclAsType(ComponentImplementation).getAllClassifiersForInstance())]
import [classifier.getPackageName()/].[classifier.getClassName()/];
	[/for]

//########## ConnectionBroker Import ###########
import de.uniaugsburg.smds.aadl2rtsj.generation.util.ConnectionBroker;

//########## Logger Import ##########
import java.util.logging.Logger;

//########## Usercode Import ##########
import [thread.getUserCodePackageName()/].[thread.getUserCodeClassName()/];

/**
 * This class represents the instance model element [thread.name/].</br>
 * It defines a ConnectionBroker for the handling of connections defined within [thread.name/] and a parent ConnectionBroker to forward or initiate data transfer into 'higher' nested components.</br>
 * It defines am out'dataPortName' method for each OUT DATA PORT, which brodcasts the given data over the parentBroker on all outgoing connections.
 * @author thomas.driessen@informatik.uni-augsburg.de
 */
public class [thread.getClassName()/] extends [classifier.getClassName()/]{	
	/**
	 * The Logger to log information on
	 */
	private static final Logger log = Logger.getLogger([thread.getClassName()/].class.getName());

	/**
	 * The AsyncEventHandler which makes this class an executable entity
	 */	
	private InnerAsyncEventHandler handler = new InnerAsyncEventHandler();

	/**
	 * The timer, that triggers the AsyncEventHandler in a periodic manner
	 */ 
	private Timer timer = new PeriodicTimer(new RelativeTime(), new RelativeTime([thread.getPeriodMilliSeconds()/], [thread.getPeriodNanoSeconds()/]), handler);

	/**
	 * ConnectionBroker to send on outgoing connections. Has to be set by the parent component.
	 */
	private ConnectionBroker parentBroker;

	/**
	 * ConnectionBroker for the connections within this Thread
	 */
	private ConnectionBroker broker;

	/**
	 * Usercode class for this Thread
	 */
	private [thread.getUserCodeClassName()/] userCode = new [thread.getUserCodeClassName()/]([classifier.getUserCodeConstructorParameters()/]);

	public [thread.getClassName()/]([classifier.getConstructorParameter()/]){
		[comment for each subcomponent we have to create an Assignment Statement/]
		[for (subcomponent : Subcomponent | classifier.oclAsType(ComponentImplementation).getAllSubComponents())]
		this.[subcomponent.name/] = [subcomponent.name/];
		[/for]
	}

	//########## Inherited Methods from ConnectionBrokerable ##########
	@Override
	public void setParentConnectionBroker(ConnectionBroker parentBroker){
		[thread.getSetParentConnectionBrokerStatements()/]
	}

	@Override
	public ConnectionBroker getConnectionBroker(){
		return broker;
	}

	[comment we have to implement the outPort wtihin the instance, becaus we only know within an instance, which name this component got as subcompnent /]
	//########## Inherited Methods from  [classifier.getClassName()/]##########
	[for (dataPort : DataPort | classifier.getAllFeatures()->select(oclIsTypeOf(DataPort)))]
		[if (dataPort.isOutgoing())]
	@Override
	public void out[dataPort.name.toUpperFirst()/]([dataPort.getClassifier().getClassName()/] data){
		[comment broadcast Ã¼ber den parentBroker /]
		parentBroker.sendOnPort("[thread.name/].[dataPort.name/]", data);
	}

		[/if]
	[/for]
	
	/**
	 * Method that is called by the AsyncEventHandler in order to map the dispatch event of an AADL thread.
	 */
	private final void dispatch() {
		[comment we need deadline statements at this point, as there is no way to hook into the JVM to listen for a deadline /]
		[let deadline : String = getProperty('Communication_Properties_IO_Reference_Time_Deadline')]
		[classifier.getStatementsForReferenceTime(deadline, parentClassifier)/]
		[/let]
		[let dispatch : String = getProperty('Communication_Properties_IO_Reference_Time_Dispatch')]
		[classifier.getStatementsForReferenceTime(dispatch, parentClassifier)/]
		[/let]
		//Execute User Code
		userCode.dispatch();
	}
	
	/**
	 * Method that is called by the AsyncEventHandler in order to map the start event of an AADL thread.
	 */
	private final void start() {
		[let start : String = getProperty('Communication_Properties_IO_Reference_Time_Start')]
			[classifier.getStatementsForReferenceTime(start, parentClassifier)/]
		[/let]
		//Execute User Code
		userCode.start();
	}
	
	/**
	 * Method that is called by the AsyncEventHandler in order to map the compute time of an AADL thread.
	 */
	private final void compute() {
		log.info("[thread.getPackageName()/].[thread.getClassName()/].compute()");
		//Execute User Code
		userCode.compute();
	}
	
	/**
	 * Method that is called by the AsyncEventHandler in order to map the completion event of an AADL thread.
	 */
	private final void completion() {
		//Execute User Code
		userCode.completion();
		[let completion : String = getProperty('Communication_Properties_IO_Reference_Time_Completion')]
			[classifier.getStatementsForReferenceTime(completion, parentClassifier)/]
		[/let]
	}
	
	/**
	 * Starts the execution of this object
	 */
	public void startExecution(){
		timer.start();
	}
	
	/**
	 * Stops the execution of this object
	 */
	public void stopExcution(){
		timer.stop();
	}

	[thread.getHandlerClass()/]
}
[/file]
[/template]

[template public getUserCodeConstructorParameters(classifier : ComponentClassifier) post (replaceAll('\n', '').trim())]
[for (feature : Feature | classifier.getAllFeatures())separator (', ')]
	[if (feature.isIncoming())]
		[if (feature.isOutgoing())]
[feature.name/].getUserInOutPort()
		[else]
[feature.name/].getUserInPort()
		[/if]
	[else]
[feature.name/].getUserOutPort()
	[/if]
[/for]
[/template]

[template private getHandlerClass(thread : ComponentInstance) post (trim()) {connection : Connection = thread.getImmediateConnection();}]
class InnerAsyncEventHandler extends [if ((connection <> null) )]Bound[/if]AsyncEventHandler{
	public InnerAsyncEventHandler(){
		setDaemon(false);
		setSchedulingParameters(new PriorityParameters([thread.getPriority()/]));
	}

	@Override
	public void handleAsyncEvent() {
	[if ((connection <> null))]
		// wait for the sending thread to finish its work
		Object sync = parentBroker.getSynchronisationObjectForConnection("[connection.name/]");
		synchronized(sync){
			try{
				while(![connection.getTargetFeature().name/].isFWDirty()){
					sync.wait();
				}
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
	[/if]
		dispatch();
		start();
		compute();
		completion();
	}
}
[/template]

[template private getHandlerType(thread : ComponentInstance) post (trim()) {connection : Connection = thread.getImmediateConnection();}]
	[if ((connection <> null))]
		BoundAsyncEventHandler
	[else]
		AsyncEventHandler
	[/if]
[/template]

[template public getStatementsForReferenceTime(classifier : ComponentClassifier, IOReferenceTime : String, parent : ComponentImplementation)post (replace('\n\n', '\n').trim())]
	[for (dataPort : DataPort | classifier.getAllFeatures()->select(oclIsTypeOf(DataPort)))]
		[if (dataPort.isIncoming())]
			[comment IGNORE Input_Time == Deadline, it seems to be forbidden by standard 8.3.2 (19) TODO: ask on mailinglist for clarification /]
			[if (IOReferenceTime <> getProperty('Communication_Properties_IO_Reference_Time_Deadline'))]
[dataPort.getDataPortInputStatementsForReferenceTime(IOReferenceTime, parent)/]
			[/if]
		[/if]
		[if (dataPort.isOutgoing())]
			[comment IGNORE Output_Time == Dispatch, it seems to be forbidden by standard 8.3.2 (27) TODO: ask on mailinglist for clarification/]
			[if (IOReferenceTime <> getProperty('Communication_Properties_IO_Reference_Time_Dispatch'))]
[dataPort.getDataPortOutputStatementsForReferenceTime(IOReferenceTime, parent)/]
			[/if]
		[/if]
	[/for]
[/template]

[comment ASSUMPTIONS/] 
[comment (1) IGNORE Input_Rate/]
[comment (2) IGNORE negative Offset part of Timing/]
[template private getDataPortInputStatementsForReferenceTime(feature : DataPort, IOReferenceTime : String, parent : ComponentImplementation)]
	[comment get all connections, where this feature is the destination/]
	[comment if immediate/delayed connections are present, then ignore Input_Time/]
	[for (connection : Connection | feature.getIncomingConnections(parent))]
		[comment in DataPorts may have only one connection per mode. We don't consider modes at the moment, so there may only be one connection/]
		[comment determine actual timing for this feature-connection-combination/] 
		[for (offsetTime : OffsetTime | feature.getTimes(connection, IOReferenceTime, true))]
			[comment as we don't consider modes, we could only take the first one/]
			[comment if outputAt is NoIO, then nothing happens, see AADL Standard 8.3.2 (19)/]
			[if(offsetTime.ioTime = IOReferenceTime)]
				[if (offsetTime.ms = 0 and offsetTime.ns = 0)]
					[comment freeze input via simple statement/]
[feature.name/].receiveInput();
				[else]
					[comment we need to generate a statement for handling via handler/]
new [getHandlerClassName(offsetTime)/]([feature.name/]);
				[/if]
			[/if]
		[/for]
	[/for]
[/template]

[comment ASSUMPTIONS/]
[comment (1) IGNORE Output_Rate/]
[comment (2) IGNORE negative Offset part of Timing/]
[template private getDataPortOutputStatementsForReferenceTime(feature : DataPort, IOReferenceTime : String, parent : ComponentImplementation)]
	[comment get all connections, where this feature is the source/]
	[comment if immediate/delayed connections are present, then partially ignore Output_Time/]
	[for (connection : Connection | feature.getOutgoingConnections(parent))]
		[comment out DataPorts may have multiple connections per mode/] 
		[comment those might have different timings/]
		[comment determine actual timing for this feature-connection-combination/] 
		[for (offsetTime : OffsetTime | feature.getTimes(connection, IOReferenceTime, false))]
			[comment if outputAt is NoIO, then nothing happens, see AADL Standard 8.3.2 (19)/]
			[if(offsetTime.ioTime = IOReferenceTime)]
				[comment deadline must be treated different, as it is always done by a handler/]
				[if(IOReferenceTime = getProperty('Communication_Properties_IO_Reference_Time_Deadline'))]
					[comment if it is an immediate connection, the handler must know it has to notify the waiting thread(s) /]
					[if (connection.getTiming() = getProperty('Communication_Properties_Timing_Immediate'))]
new [getHandlerClassName(offsetTime)/]([feature.name/], parentBroker, "[connection.name/]", true);
					[else]
new [getHandlerClassName(offsetTime)/]([feature.name/], parentBroker, "[connection.name/]", false);
					[/if]
				[elseif ((offsetTime.ms = 0) and (offsetTime.ns = 0))]
				[comment] 
				send output, but only for this specific connection via simple statement
 				see AADL Standard 8.3.2 (29)
				[/comment]
parentBroker.sendOnConnection("[connection.name/]", [feature.name/].getFWData());
					[comment if it is an immediate connection, the handler must know it has to notify the waiting thread(s) /]
					[if (connection.getTiming() = getProperty('Communication_Properties_Timing_Immediate'))]
Object sync = parentBroker.getSynchronisationObjectForConnection("[connection.name/]");
synchronized(sync){
	sync.notifyAll();
}
					[/if]
				[comment we need to generate a statement for handling via handler/]
				[else]
					[comment if it is an immediate connection, the handler must know it has to notify the waiting thread(s) /]
					[if (connection.getTiming() = getProperty('Communication_Properties_Timing_Immediate'))]
new [getHandlerClassName(offsetTime)/]([feature.name/], parentBroker, "[connection.name/]", true);
					[else]
new [getHandlerClassName(offsetTime)/]([feature.name/], parentBroker, "[connection.name/]", false);
					[/if]
				[/if]
			[/if]
		[/for]
	[/for]
[/template]
