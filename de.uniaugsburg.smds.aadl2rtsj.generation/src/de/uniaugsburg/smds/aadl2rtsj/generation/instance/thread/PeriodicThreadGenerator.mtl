[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate.
 */]
[module PeriodicThreadGenerator('http://aadl.info/AADL/2.0', 'http://aadl.info/AADL/2.0/instance', 'http://www.uniaugsburg.de/smds/aadl2rtsj/generation/util')]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ComponentInstanceHelper /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ComponentClassifierHelper /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::PropertyHelper /]

[template public generatePeriodicThread(thread : ComponentInstance)? (isPeriodic(thread)) { classifier : ComponentClassifier = thread.getClassifier(); }]
[file(getPackageName(thread).substitute('.', '/').concat('/').concat(getClassName(thread)).concat('.java') , false, 'UTF-8')]
package [getPackageName(thread)/];

import javax.realtime.Timer;
import javax.realtime.OneShotTimer;
import javax.realtime.RelativeTime;
import javax.realtime.PeriodicTimer;
[comment if this thread has a immediate connection where it is the target, it has to wait and therefore needs to be a BoundAsyncEventHandler. Otherwise it's just an AsyncEventHandler /]
import javax.realtime.[getHandlerType(thread)/];
import javax.realtime.PriorityParameters;

[comment Create an Import Statement for each Subcomponent, Features are in the same package and don't need an Import Statement /]
[for (subcomponent : ComponentInstance | getSubcomponents(thread))]
import [getPackageName(subcomponent)/].[getClassName(subcomponent)/];
[/for]

[if (classifier.oclIsTypeOf(ComponentType))]
//########## Feature Classifier Imports ##########
	[comment import all classifiers of the features, but only once for each classifier/]
	[for (featureClassifier : ComponentClassifier | classifier.getFeatureClassifiers())]
import [featureClassifier.getPackageName()/].[featureClassifier.getClassName()/];
	[/for]

//########## Port Variable Imports ##########
	[comment if this component has in, out or in/out ports we have to import the respective port type/]
	[if (classifier.getFeatures()->select(oclIsTypeOf(DataPort))->size() > 0)]
import de.uniaugsburg.smds.aadl2rtsj.generation.util.DataPort;
	[/if]
[/if]
import [classifier.getPackageName()/].[classifier.getClassName()/];

public class [getClassName(thread)/][if (classifier.oclIsTypeOf(ComponentType))] implements [else] extends [/if][classifier.getClassName()/]{	
	[if (classifier.oclIsTypeOf(ComponentType))]
		[comment create a data port variable for each dataport /]
		//########## Data Port Variables ###########
		[for (dataPort : DataPort | classifier.getFeatures()->select(oclIsTypeOf(DataPort)))]
	protected DataPort<[dataPort.getClassifier().getClassName()/]> [dataPort.name/] = new DataPort<[dataPort.getClassifier().getClassName()/]>();
		[/for]
	[/if]
	private AsyncEventHandler handler = new InnerAsyncEventHandler();
	private Timer timer = new PeriodicTimer(new RelativeTime(), new RelativeTime([getPeriodMilliSeconds(thread)/], [getPeriodNanoSeconds(thread)/]), handler);
	
	[comment Create a Member Statement for each Subcomponent /]
	[for (subcomponent : ComponentInstance | getSubcomponents(thread))]
	private [getClassName(subcomponent)/] [getObjectName(subcomponent)/];
	[/for]
	[comment Create a Member Statement for each Feature/]
	[for (feature : FeatureInstance | getFeatures(thread))]
	private [getClassName(feature)/] [getObjectName(feature)/];
	[/for]
	[comment consider possible Member Statement for Synchronisation Object/]
	[let connection : ConnectionInstance = getImmediateConnection(thread)]
	private Object [getSynchronisationObjectName(connection)/];
	[/let]	

	public [getClassName(thread)/]([getConstructorParameters(thread)/]){
		[comment for each feature we have to create an Assignment Statement/]
		[for (feature : FeatureInstance | getFeatures(thread))]
		this.[getObjectName(feature)/] = [getObjectName(feature)/];
		[/for]

		[comment for each subcomponent we have to create an Assignment Statement/]
		[if (getSubcomponents(thread)->size() > 0)]
			[for (subcomponent : ComponentInstance | getSubcomponents(thread))]
				[if (i > 1)]
		this.[getObjectName(subcomponent)/] = [getObjectName(subcomponent)/];
				[/if]
			[/for]
		[/if]
		
		[comment consider possible synchronisationobjects/]
		[comment TODO: what if there are multiple immediate connections for this CI?/]
		[let connection : ConnectionInstance = getImmediateConnection(thread)]
		this.[getSynchronisationObjectName(connection)/] = [getSynchronisationObjectName(connection)/];
		[/let]		
	}

	[if (classifier.oclIsTypeOf(ComponentType))]
	//########## Inherited Methods from [classifier.getClassName()/] ###########
		[for (dataPort : DataPort | classifier.getFeatures()->select(oclIsTypeOf(DataPort)))]
			[if (dataPort.isIncoming())]
	@Override
	public void in[dataPort.name.toUpperFirst()/]([dataPort.getClassifier().getClassName()/] data){
		[dataPort.name/].setData(data);
	}
			[/if]
		[/for]
	[/if]

	[comment we have to implement the outPort here, becaus we only know within an instance, which name this component got as subcompnent /]
	[for (dataPort : DataPort | classifier.getFeatures()->select(oclIsTypeOf(DataPort)))]
		[if (dataPort.isOutgoing())]
	private void out[dataPort.name.toUpperFirst()/]([dataPort.getClassifier().getClassName()/] data){
		[comment broadcast Ã¼ber den parentBroker /]
		parentBroker.sendOnPort("[thread.name/].[dataPort.name/]", data);
	}
		[/if]
	[/for]

	
	private final void dispatch() {
		[getStatementsForReferenceTime(thread, getProperty('Communication_Properties_IO_Reference_Time_Dispatch'))/]
		[comment we need deadline statements at this point, as there is no way to hook into the JVM to listen for a deadline /]
		[getStatementsForReferenceTime(thread, getProperty('Communication_Properties_IO_Reference_Time_Deadline'))/]
	}
	
	private final void start() {
		[getStatementsForReferenceTime(thread, getProperty('Communication_Properties_IO_Reference_Time_Start'))/]
	}
	
	private final void compute() {
		System.out.println("[getPackageName(thread)/].[getClassName(thread)/].compute()");
	}
	
	private final void completion() {
		[getStatementsForReferenceTime(thread, getProperty('Communication_Properties_IO_Reference_Time_Completion'))/]
	}
	
	/**
	 * Starts the execution of this object
	 */
	public void startExecution(){
		timer.start();
	}
	
	/**
	 * Stops the execution of this object
	 */
	public void stopExcution(){
		timer.stop();
	}

	[getHandlerClass(thread)/]
}
[/file]
[/template]

[template private getHandlerClass(thread : ComponentInstance) post (trim()) {connection : ConnectionInstance = getImmediateConnection(thread);}]
	
class InnerAsyncEventHandler extends [if ((connection <> null) and (getComponentInstance(getConnectionDestination(connection)) = thread))]Bound[/if]AsyncEventHandler{
	public InnerAsyncEventHandler(){
		setDaemon(false);
		setSchedulingParameters(new PriorityParameters([getPriority(thread)/]));
	}

	@Override
	public void handleAsyncEvent() {
	[if ((connection <> null) and (getComponentInstance(getConnectionDestination(connection)) = thread))]
		synchronized([getSynchronisationObjectName(connection)/]){
			try{
				// TODO: not yet sure how to solve synchronization for immediate connections 
				//while(![getObjectName(connection)/].isDirty()){
					[getSynchronisationObjectName(connection)/].wait();
				//}
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
	[/if]
		dispatch();
		start();
		compute();
		completion();
	}
}
[/template]

[template private getHandlerType(thread : ComponentInstance) post (trim()) {connection : ConnectionInstance = getImmediateConnection(thread);}]
	[if ((connection <> null) and (getComponentInstance(getConnectionDestination(connection)) = thread))]
		BoundAsyncEventHandler
	[else]
		AsyncEventHandler
	[/if]
[/template]

[template private getConstructorParameters(thread : ComponentInstance) post (replaceAll('\n', '').trim()) {connection : ConnectionInstance = getImmediateConnection(thread);}]
	[for (feature : FeatureInstance | getFeatures(thread)) separator (', ')]
[getClassName(feature)/] [getObjectName(feature)/]
	[/for]
	[if (getSubcomponents(thread)->size() > 0)]
, 
	[/if]
	[for (subcomponent : ComponentInstance | getSubcomponents(thread)) separator (', ')]
[getClassName(subcomponent)/] [getObjectName(subcomponent)/]
	[/for]
	[if (connection <> null)]
, Object [getSynchronisationObjectName(connection)/]
	[/if]
[/template]

[template public getStatementsForReferenceTime(thread : ComponentInstance, IOReferenceTime : String)post (trim())]
	[for (feature : FeatureInstance | getFeatures(thread))]
		[if (isDataPort(feature))]
			[if (isIncoming(feature))]
				[comment IGNORE Input_Time == Deadline, it seems to be forbidden by standard 8.3.2 (19) TODO: ask on mailinglist for clarification /]
				[if (IOReferenceTime <> getProperty('Communication_Properties_IO_Reference_Time_Deadline'))]
[getDataPortInputStatementsForReferenceTime(feature, IOReferenceTime)/]
				[/if]
			[/if]
			[if (isOutgoing(feature))]
				[comment IGNORE Output_Time == Dispatch, it seems to be forbidden by standard 8.3.2 (27) TODO: ask on mailinglist for clarification/]
				[if (IOReferenceTime <> getProperty('Communication_Properties_IO_Reference_Time_Dispatch'))]
[getDataPortOutputStatementsForReferenceTime(feature, IOReferenceTime)/]
				[/if]
			[/if]
		[/if]
	[/for]
[/template]

[comment ASSUMPTIONS/] 
[comment (1) IGNORE Input_Rate/]
[comment (2) IGNORE negative Offset part of Timing/]
[template private getDataPortInputStatementsForReferenceTime(feature : FeatureInstance, IOReferenceTime : String)]
	[comment get all connections, where this feature is the destination/]
	[comment if immediate/delayed connections are present, then ignore Input_Time/]
	[for (connection : ConnectionInstance | getDstConnectionInstances(feature))]
		[comment in DataPorts may have only one connection per mode. We don't consider modes at the moment, so there may only be one connection/]
		[comment determine actual timing for this feature-connection-combination/] 
		[for (offsetTime : OffsetTime | getTimes(feature, connection, IOReferenceTime, true))]
			[comment as we don't consider modes, we could only take the first one/]
			[comment if outputAt is NoIO, then nothing happens, see AADL Standard 8.3.2 (19)/]
			[if(offsetTime.ioTime = IOReferenceTime)]
				[if (offsetTime.ms = 0 and offsetTime.ns = 0)]
					[comment freeze input via simple statement/]
[getObjectName(feature)/].receiveInput();
				[else]
					[comment we need to generate a statement for handling via handler/]
Timer timerFor[getHandlerClassName(feature, offsetTime)/] = new OneShotTimer(new RelativeTime([offsetTime.ms/], [offsetTime.ns/]), new [getHandlerClassName(feature, offsetTime)/]([getObjectName(feature)/]));
timerFor[getHandlerClassName(feature, offsetTime)/].start();
				[/if]
			[/if]
		[/for]
	[/for]
[/template]

[comment ASSUMPTIONS/]
[comment (1) IGNORE Output_Rate/]
[comment (2) IGNORE negative Offset part of Timing/]
[template private getDataPortOutputStatementsForReferenceTime(feature : FeatureInstance, IOReferenceTime : String)]
	[comment get all connections, where this feature is the source/]
	[comment if immediate/delayed connections are present, then partially ignore Output_Time/]
	[for (connection : ConnectionInstance | getSrcConnectionInstances(feature))]
		[comment out DataPorts may have multiple connections per mode/] 
		[comment those might have different timings/]
		[comment determine actual timing for this feature-connection-combination/] 
		[for (offsetTime : OffsetTime | getTimes(feature, connection, IOReferenceTime, false))]
			[comment if outputAt is NoIO, then nothing happens, see AADL Standard 8.3.2 (19)/]
			[if(offsetTime.ioTime = IOReferenceTime)]
				[comment deadline must be treated different, as it is always done by a handler/]
				[if(IOReferenceTime = getProperty('Communication_Properties_IO_Reference_Time_Deadline'))]
Timer timerFor[getHandlerClassName(feature, offsetTime)/] = new OneShotTimer(timer.getFireTime(), new [getHandlerClassName(feature, offsetTime)/]([getObjectName(feature)/]));
timerFor[getHandlerClassName(feature, offsetTime)/].start();
				[elseif ((offsetTime.ms = 0) and (offsetTime.ns = 0))]
					[comment send output, but only for this specific connection via simple statement/]
					[comment see AADL Standard 8.3.2 (29)/]
[comment getObjectName(feature)/][ comment .sendOutputOn[getClassName(connection)/][comment ();/]
parentBroker.sendOnConnection("[connection.getObjectName()/]", [feature.getObjectName()/].getData());
				[else]
					[comment we need to generate a statement for handling via handler/]
Timer timerFor[getHandlerClassName(feature, offsetTime)/] = new OneShotTimer(new RelativeTime([offsetTime.ms/], [offsetTime.ns/]), new [getHandlerClassName(feature, offsetTime)/]([getObjectName(feature)/]));
timerFor[getHandlerClassName(feature, offsetTime)/].start();
				[/if]
			[/if]
		[/for]
	[/for]
[/template]
