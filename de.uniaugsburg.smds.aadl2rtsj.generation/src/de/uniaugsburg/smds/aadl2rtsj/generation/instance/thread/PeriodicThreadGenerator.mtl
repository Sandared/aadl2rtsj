[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate.
 */]
[module PeriodicThreadGenerator('http://aadl.info/AADL/2.0', 'http://aadl.info/AADL/2.0/instance', 'http://www.uniaugsburg.de/smds/aadl2rtsj/generation/util')]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ComponentInstanceHelper /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ComponentClassifierHelper /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::util::InnerConnectionBrokerGenerator /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::PropertyHelper /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::util::IOHandlerGenerator /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::user::ThreadUserCodeGenerator /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::instance::util::InstanceHelper /]

[template public generatePeriodicThread(thread : ComponentInstance)? (isPeriodic(thread)) { classifier : ComponentClassifier = thread.getClassifier(); }]
[file(getPackageName(thread).substitute('.', '/').concat('/').concat(getClassName(thread)).concat('.java') , false, 'UTF-8')]
package [getPackageName(thread)/];

import javax.realtime.Timer;
import javax.realtime.OneShotTimer;
import javax.realtime.RelativeTime;
import javax.realtime.PeriodicTimer;
[comment if this thread has an immediate connection where it is the target, it has to wait and therefore needs to be a BoundAsyncEventHandler. Otherwise it's just an AsyncEventHandler /]
import javax.realtime.[getHandlerType(thread)/];
import javax.realtime.PriorityParameters;

//########## Classifier Imports ##########
	[comment import all classifiers of this ThreadImplementation, but only once for each classifier/]
	[for (classifier : ComponentClassifier | thread.getClassifier().oclAsType(ComponentImplementation).getAllClassifiersForInstance())]
import [classifier.getPackageName()/].[classifier.getClassName()/];
	[/for]

//########## ConnectionBroker Import ###########
import de.uniaugsburg.smds.aadl2rtsj.generation.util.ConnectionBroker;

//########## Logger Import ##########
import java.util.logging.Logger;

public class [getClassName(thread)/] extends [classifier.getClassName()/]{	
	private static final Logger log = Logger.getLogger([thread.getClassName()/].class.getName());	
	private AsyncEventHandler handler = new InnerAsyncEventHandler();
	private Timer timer = new PeriodicTimer(new RelativeTime(), new RelativeTime([getPeriodMilliSeconds(thread)/], [getPeriodNanoSeconds(thread)/]), handler);

	/**
	 * ConnectionBroker to send on outgoing connections. Has to be set by the parent component.
	 */
	private ConnectionBroker parentBroker;

	/**
	 * ConnectionBroker for the connections within this Thread
	 */
	private ConnectionBroker broker;

	/**
	 * Usercode class for this Thread
	 */
	private [thread.getClassName()/]UserCode userCode = new [thread.getClassName()/]UserCode([thread.getUserCodeConstructorParameters()/]);

	public [getClassName(thread)/]([thread.getConstructorParameters()/]){
		[comment for each subcomponent we have to create an Assignment Statement/]
		[for (subcomponent : Subcomponent | classifier.oclAsType(ComponentImplementation).getAllSubComponents())]
		this.[subcomponent.name/] = [subcomponent.name/];
		[/for]
	}

	//########## Inherited Methods from ConnectionBrokerable ##########
	@Override
	public void setParentConnectionBroker(ConnectionBroker parentBroker){
		[getSetParentConnectionBrokerStatements(thread)/]
	}

	@Override
	public ConnectionBroker getConnectionBroker(){
		return broker;
	}

	[comment we have to implement the outPort wtihin the instance, becaus we only know within an instance, which name this component got as subcompnent /]
	//########## Inherited Methods from  [classifier.getClassName()/]##########
	[for (dataPort : DataPort | classifier.getAllFeatures()->select(oclIsTypeOf(DataPort)))]
		[if (dataPort.isOutgoing())]
	/**
	 * This method broadcasts the given data on all outgoing connections of <code>[dataPort.name/]</code></br>
	 * via the <code>parentBroker</code> of this thread.
	 * @param data the data to be broadcasted on the OUT DATA PORT <code>[dataPort.name/]</code>
	 */
	@Override
	protected void out[dataPort.name.toUpperFirst()/]([dataPort.getClassifier().getClassName()/] data){
		[comment broadcast Ã¼ber den parentBroker /]
		parentBroker.sendOnPort("[thread.name/].[dataPort.name/]", data);
	}
		[/if]
	[/for]
	
	private final void dispatch() {
		[comment we need deadline statements at this point, as there is no way to hook into the JVM to listen for a deadline /]
		[thread.getStatementsForReferenceTime(getProperty('Communication_Properties_IO_Reference_Time_Deadline'))/]
		[thread.getStatementsForReferenceTime(getProperty('Communication_Properties_IO_Reference_Time_Dispatch'))/]
		//Execute User Code
		userCode.dispatch();
	}
	
	private final void start() {
		[thread.getStatementsForReferenceTime(getProperty('Communication_Properties_IO_Reference_Time_Start'))/]
		//Execute User Code
		userCode.start();
	}
	
	private final void compute() {
		System.out.println("[thread.getPackageName()/].[thread.getClassName()/].compute()");
		//Execute User Code
		userCode.compute();
	}
	
	private final void completion() {
		[thread.getStatementsForReferenceTime(getProperty('Communication_Properties_IO_Reference_Time_Completion'))/]
		//Execute User Code
		userCode.completion();
	}
	
	/**
	 * Starts the execution of this object
	 */
	public void startExecution(){
		timer.start();
	}
	
	/**
	 * Stops the execution of this object
	 */
	public void stopExcution(){
		timer.stop();
	}

	[thread.getHandlerClass()/]
}
[/file]

[comment generate Connection Broker for this thread /]
[thread.generateInnerConnectionBroker()/]

[comment generate IOHandler if necessary /]
[for (fi : FeatureInstance | thread.getFeatures())]
	[for (time : OffsetTime | getTimes(fi))]
		[comment only do something if there is an offset or if it is at deadline, at deadline we always have to use handlers/]
		[if ((time.ioTime = getProperty('Communication_Properties_IO_Reference_Time_Deadline')) or (time.ms <> 0 or time.ns <> 0))]
			[if (fi.isIncoming())]
				[generateInputHandler(thread, fi, time)/]
			[/if]
			[if (fi.isOutgoing())]
				[generateOutputHandler(thread, fi, time)/]
			[/if]
		[/if]
	[/for]
[/for]

[comment generate Usercode class for this thread /]
[generateUserCode(thread)/]
[/template]

[template public getUserCodeConstructorParameters(thread : ComponentInstance) post (replaceAll('\n', '').trim())]
[for (feature : FeatureInstance | thread.getFeatures())separator (',')]
	[if (feature.isIncoming())]
		[if (feature.isOutgoing())]
[feature.getObjectName()/].getUserInOutPort()
		[else]
[feature.getObjectName()/].getUserInPort()
		[/if]
	[else]
[feature.getObjectName()/].getUserOutPort()
	[/if]
[/for]
[/template]

[template private getHandlerClass(thread : ComponentInstance) post (trim()) {connection : ConnectionInstance = getImmediateConnection(thread);}]
class InnerAsyncEventHandler extends [if ((connection <> null) and (getComponentInstance(getConnectionDestination(connection)) = thread))]Bound[/if]AsyncEventHandler{
	public InnerAsyncEventHandler(){
		setDaemon(false);
		setSchedulingParameters(new PriorityParameters([getPriority(thread)/]));
	}

	@Override
	public void handleAsyncEvent() {
	[if ((connection <> null) and (getComponentInstance(getConnectionDestination(connection)) = thread))]
		synchronized([getSynchronisationObjectName(connection)/]){
			try{
				while(![connection.destination.name/].isDirty()){
					parentBroker.getSynchronisationObjectForConnection([connection.getObjectName()/]).wait();
				}
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
	[/if]
		dispatch();
		start();
		compute();
		completion();
	}
}
[/template]

[template private getHandlerType(thread : ComponentInstance) post (trim()) {connection : ConnectionInstance = getImmediateConnection(thread);}]
	[if ((connection <> null) and (getComponentInstance(getConnectionDestination(connection)) = thread))]
		BoundAsyncEventHandler
	[else]
		AsyncEventHandler
	[/if]
[/template]

[template public getStatementsForReferenceTime(thread : ComponentInstance, IOReferenceTime : String)post (replace('\n\n', '\n').trim())]
	[for (feature : FeatureInstance | getFeatures(thread))]
		[if (isDataPort(feature))]
			[if (isIncoming(feature))]
				[comment IGNORE Input_Time == Deadline, it seems to be forbidden by standard 8.3.2 (19) TODO: ask on mailinglist for clarification /]
				[if (IOReferenceTime <> getProperty('Communication_Properties_IO_Reference_Time_Deadline'))]
[getDataPortInputStatementsForReferenceTime(feature, IOReferenceTime)/]
				[/if]
			[/if]
			[if (isOutgoing(feature))]
				[comment IGNORE Output_Time == Dispatch, it seems to be forbidden by standard 8.3.2 (27) TODO: ask on mailinglist for clarification/]
				[if (IOReferenceTime <> getProperty('Communication_Properties_IO_Reference_Time_Dispatch'))]
[getDataPortOutputStatementsForReferenceTime(feature, IOReferenceTime)/]
				[/if]
			[/if]
		[/if]
	[/for]
[/template]

[comment ASSUMPTIONS/] 
[comment (1) IGNORE Input_Rate/]
[comment (2) IGNORE negative Offset part of Timing/]
[template private getDataPortInputStatementsForReferenceTime(feature : FeatureInstance, IOReferenceTime : String)]
	[comment get all connections, where this feature is the destination/]
	[comment if immediate/delayed connections are present, then ignore Input_Time/]
	[for (connection : ConnectionInstance | getDstConnectionInstances(feature))]
		[comment in DataPorts may have only one connection per mode. We don't consider modes at the moment, so there may only be one connection/]
		[comment determine actual timing for this feature-connection-combination/] 
		[for (offsetTime : OffsetTime | getTimes(feature, connection, IOReferenceTime, true))]
			[comment as we don't consider modes, we could only take the first one/]
			[comment if outputAt is NoIO, then nothing happens, see AADL Standard 8.3.2 (19)/]
			[if(offsetTime.ioTime = IOReferenceTime)]
				[if (offsetTime.ms = 0 and offsetTime.ns = 0)]
					[comment freeze input via simple statement/]
[feature.getObjectName()/].receiveInput();
				[else]
					[comment we need to generate a statement for handling via handler/]
new [getHandlerClassName(offsetTime)/]([getObjectName(feature)/]);
				[/if]
			[/if]
		[/for]
	[/for]
[/template]

[comment ASSUMPTIONS/]
[comment (1) IGNORE Output_Rate/]
[comment (2) IGNORE negative Offset part of Timing/]
[template private getDataPortOutputStatementsForReferenceTime(feature : FeatureInstance, IOReferenceTime : String)]
	[comment get all connections, where this feature is the source/]
	[comment if immediate/delayed connections are present, then partially ignore Output_Time/]
	[for (connection : ConnectionInstance | getSrcConnectionInstances(feature))]
		[comment out DataPorts may have multiple connections per mode/] 
		[comment those might have different timings/]
		[comment determine actual timing for this feature-connection-combination/] 
		[for (offsetTime : OffsetTime | getTimes(feature, connection, IOReferenceTime, false))]
			[comment if outputAt is NoIO, then nothing happens, see AADL Standard 8.3.2 (19)/]
			[if(offsetTime.ioTime = IOReferenceTime)]
				[comment deadline must be treated different, as it is always done by a handler/]
				[if(IOReferenceTime = getProperty('Communication_Properties_IO_Reference_Time_Deadline'))]
new [getHandlerClassName(offsetTime)/]([getObjectName(feature)/], parentBroker, "[connection.getObjectName()/]");
				[elseif ((offsetTime.ms = 0) and (offsetTime.ns = 0))]
					[comment send output, but only for this specific connection via simple statement/]
					[comment see AADL Standard 8.3.2 (29)/]
[comment getObjectName(feature)/][ comment .sendOutputOn[getClassName(connection)/][comment ();/]
parentBroker.sendOnConnection("[connection.getObjectName()/]", [feature.getObjectName()/].getFWData());
				[else]
					[comment we need to generate a statement for handling via handler/]
new [getHandlerClassName(offsetTime)/]([getObjectName(feature)/], parentBroker, "[connection.getObjectName()/]");
				[/if]
			[/if]
		[/for]
	[/for]
[/template]
