[comment encoding = UTF-8 /]
[module ThreadImplementationGenerator('http://aadl.info/AADL/2.0', 'http://aadl.info/AADL/2.0/instance')]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ComponentClassifierHelper /]

[template public generateThreadImplementation(thread : ComponentClassifier)]
[let threadImpl : ThreadImplementation = thread]
[file(threadImpl.getPackageName().substitute('.', '/').concat('/').concat(threadImpl.getClassName(threadImpl)).concat('.java') , false, 'UTF-8')]
package [threadImpl.getPackageName()/];

//########## Classifier Imports ##########
	[comment import all classifiers of this ThreadImplementation, but only once for each classifier/]
	[for (classifier : ComponentClassifier | threadImpl.getAllClassifiers())]
import [classifier.getPackageName()/].[classifier.getClassName()/];
	[/for]

//########## Port Variable Import ##########
	[comment if this component has in, out or in/out ports we have to import DataPort/]
	[if (threadImpl.getFeatures()->select(oclIsTypeOf(DataPort))->size() > 0)]
import de.uniaugsburg.smds.aadl2rtsj.generation.util.DataPort;
	[/if]

//########## ConnectionBroker Import ###########
import de.uniaugsburg.smds.aadl2rtsj.generation.util.ConnectionBroker;

//########## Logger Import ##########
import java.util.logging.Logger;

public class [threadImpl.getClassName()/][if (threadImpl.getExtendedClassifier() <> null)] extends [threadImpl.getExtendedClassifier().getClassName()/][/if] implements [threadImpl.getRealizedClassifier().getClassName()/]{
	private static final Logger log = Logger.getLogger([threadImpl.getClassName()/].class.getName());	

	//ConnectionBroker to send on outgoing connections. Has to be set by the parent component.
	protected ConnectionBroker parentBroker;

	[if (threadImpl.getAllConnections()->size() > 0)]
	//ConnectionBroker for the connections within this Thread
	protected ConnectionBroker broker = new InnerConnectionBroker();
	[/if]

	//########## Subcomponent Variables ##########
	[for (subcomponent : Subcomponent | threadImpl.getOwnSubcomponents())]
	protected [subcomponent.getClassifier().getClassName()/] [subcomponent.name/];
	[/for]

	[comment create a data port variable for each IN DATAPORT that has no connections within this component/]
	//########## Data Port Variables ###########
	[for (dataPort : DataPort | threadImpl.getFeatures()->select(oclIsTypeOf(DataPort)))]
	protected DataPort<[dataPort.getClassifier().getClassName()/]> [dataPort.name/] = new DataPort<[dataPort.getClassifier().getClassName()/]>();
	[/for]

	//########## Inherited Methods from [threadImpl.getRealizedClassifier().getClassName()/] ###########
	[for (dataPort : DataPort | threadImpl.getFeatures()->select(oclIsTypeOf(DataPort)))]
		[if (dataPort.isIncoming())]
	@Override
	public void in[dataPort.name.toUpperFirst()/]([dataPort.getClassifier().getClassName()/] data){
		//TODO
	}
		[/if]
		[if (dataPort.isOutgoing())]
	private void out[dataPort.name.toUpperFirst()/]([dataPort.getClassifier().getClassName()/] data){
		[comment broadcast Ã¼ber den parentBroker /]
		parentBroker.sendOnPort("[dataPort.name/]", data);
	}
		[/if]
	[/for]

	//########## Parent ConnectionBroker Method ##########
	public void setParentConnectionBroker(ConnectionBroker parentBroker){
		this.parentBroker = parentBroker;
	}

	[comment if there are no connections within this component we don't have to do anything /]
	[if (threadImpl.getAllConnections()->size() > 0)]
	class InnerConnectionBroker implements ConnectionBroker{
		@Override
		public void sendOnConnection(String connection, Object data){
			switch (connection) {
		[for (connection : Connection | threadImpl.getAllConnections())]
			case [connection.name/]:
			[let port : DataPort = connection.getTargetFeature()]
				[let target : Subcomponent = connection.getTargetComponent()]
				[comment if the connection target is a Subcomponent it means we have to use the inPort of this subcomponent, which is declared in it's interface /]
				[target.name/].in[port.name.toUpperFirst()/](([port.getClassifier().getClassName()/])data);
				break;
				[elselet target : ThreadImplementation = connection.getTargetComponent()]
				[comment else we send on the outport of this component, which is basically a broadcast/]
				this.out[port.name.toUpperFirst()/](([port.getClassifier().getClassName()/])data);
				[/let]
			[/let]
		[/for]
			default:
				log.warning("No connection to send on found for: " + connection);
				break;
			}
		}
		
		@Override
		public void sendOnPort(String port, Object data){
			switch (port) {
		[comment for each subcomponent we search for outgoing dataPorts and create a sendOnConnection(...) method for each connection, that has this dataPort as source /]
		[for (subcomponent : ComponentClassifier | threadImpl.getSubComponentClassifiers())]
			[for (dataPort : DataPort | subcomponent.getFeatures()->select(oclIsTypeOf(DataPort)))]
				[if (dataPort.isOutgoing())]
				case [dataPort.name/]:
					[for (connection : Connection | threadImpl.getAllConnections())]
						[if (connection.getSourceFeature() = dataPort)]
							[let target : DataPort = connection.getTargetFeature()]
					sendOnConnection("[connection.name/]", ([target.getClassifier()/])data);
							[/let]
						[/if]
					[/for]	
					break;
				[/if]
			[/for]
		[/for]
			default:
				log.warning("No port to send on found for: " + port);
				break;
			}
		}
		
	}
	[/if]
}
[/file]	
[/let]
[/template]
