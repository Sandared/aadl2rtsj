[comment encoding = UTF-8 /]
[module InnerConnectionBrokerGenerator('http://aadl.info/AADL/2.0/instance', 'http://aadl.info/AADL/2.0')]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ComponentClassifierHelper /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ComponentInstanceHelper /]
[template public generateInnerConnectionBroker(instance : ComponentInstance)]
[file(instance.getConnectionBrokerFileName() , false, 'UTF-8')]
package [instance.getPackageName()/];

import java.util.Map;
import java.util.HashMap;

//########## Classifier Imports ##########
	[comment import all classifiers of this Broker's ComponentImplemntation, but only once for each classifier/]
	[for (classifier : ComponentClassifier | instance.getClassifier().oclAsType(ComponentImplementation).getAllClassifiersForConnectionBroker())]
import [classifier.getPackageName()/].[classifier.getClassName()/];
	[/for]

//########## ConnectionBroker Import ###########
import de.uniaugsburg.smds.aadl2rtsj.generation.util.ConnectionBroker;
import de.uniaugsburg.smds.aadl2rtsj.generation.util.BasicConnectionBroker;

//########## Logger Import ##########
import java.util.logging.Logger;

/**
 * The standard ConnectionBroker to be used by components with inner connections.
 * @author thomas.driessen@informatik.uni-augsburg.de
 */
public class [instance.getClassName()/]ConnectionBroker extends BasicConnectionBroker{

	/**
	 * A logger for logging errors/warnings/etc.
	 */
	private static final Logger log = Logger.getLogger([instance.getClassName()/]ConnectionBroker.class.getName());

	/**
	 * A map of synchronisation Objects. For each subcomponent that is the ultimative source of a connection</br>
	 * where a syncObject is needed (immediate connection), a syncObject is created lazily and stored in this Map.
	 */
	private Map<String, Object> syncObjects = new HashMap<String, Object>();

	/**
	 * Broker to be used when retrieving syncObjects from 'higher' nested components
	 */
	private ConnectionBroker parentBroker;

	/**
	 * Component whose out ports are to be used when forwarding connections to 'higher' nested components
	 */
	private [instance.getClassifier().getClassName()/] component;
	[comment for each subcomponent we have to create an member variable/]
	[if (instance.getClassifier().oclAsType(ComponentImplementation).getAllSubComponents()->size() > 0)]
		[for (subcomponent : Subcomponent | instance.getClassifier().oclAsType(ComponentImplementation).getAllSubComponents())]

	/**
	 * Subcomponent whose IN ports are to be used when forwarding connections to 'deeper' nested components
	 */
	private [subcomponent.getClassifier().getClassName()/] [subcomponent.name/];
		[/for]
	[/if]	

	public [instance.getClassName()/]ConnectionBroker([instance.getConstructorParameters()/]){
		this.parentBroker = parentBroker;
		this.component = component;
		[comment for each subcomponent we have to create an Assignment Statement/]
		[if (instance.getClassifier().oclAsType(ComponentImplementation).getAllSubcomponents()->size() > 0)]
			[for (subcomponent : Subcomponent | instance.getClassifier().oclAsType(ComponentImplementation).getAllSubcomponents())]
		this.[subcomponent.name/] = [subcomponent.name/];
			[/for]
		[/if]	
	}

	@Override
	public void sendOnConnection(String connection, Object data){
		switch (connection) {
[let classifier : ComponentImplementation = instance.getClassifier()]
	[for (connection : Connection | classifier.getAllConnections())]
		case "[connection.name/]":
		[let port : DataPort = connection.getTargetFeature()]
			[let target : Subcomponent = connection.getTargetComponent()]
			[comment if the connection target is a Subcomponent it means we have to use the inPort of this subcomponent, which is declared in it's interface /]
			// "[port.name/]" is the target feature of "[connection.name/]" 
			// which is a connection between subcomponents of "[instance.getClassName()/]", 
			// so call its corresponding in method
			[target.name/].in[port.name.toUpperFirst()/](([port.getClassifier().getClassName()/])data);
			break;
			[elselet target : ComponentImplementation = connection.getTargetComponent()]
			[comment else we send on the outport of this component, which is basically a broadcast/]
			// "[port.name/]" is the target feature of "[connection.name/]" 
			// which is a connection from a subcomponent of "[instance.getClassName()/]" to "[instance.getClassName()/]" itself, 
			// so call its corresponding out mehtod
			component.out[port.name.toUpperFirst()/](([port.getClassifier().getClassName()/])data);
			break;
			[/let]
		[/let]
	[/for]
[/let]
		default:
			log.severe("No connection to send on found for: " + connection);
			break;
		}
	}
	
	@Override
	public void sendOnPort(String port, Object data){
		switch (port) {
[comment for each subcomponent we search for outgoing dataPorts and create a sendOnConnection(...) method for each connection, that has this dataPort as source /]
[for (subcomponent : ComponentInstance | instance.getChildren()->select(oclIsTypeOf(ComponentInstance)))]
	[for (dataPort : FeatureInstance | subcomponent.featureInstance)]
		[if (dataPort.direction = DirectionType::out or dataPort.direction = DirectionType::inOut)]
		[comment we use the port name concatenated with the subcomponent name, because in the contex of the parent object a subcomponents port name might not be unique /]
		case "[subcomponent.name/].[dataPort.name/]":
			[for (connection : Connection | instance.getAllEnclosingConnectionInstances().connectionReference->select(p|p.source = dataPort).connection)]
			sendOnConnection("[connection.name/]", data);
			[/for]
			break;
		[/if]
	[/for]
[/for]
		default:
			log.severe("No port to send on found for: " + port);
			break;
		}
	}

	@Override
	public Object getSynchronisationObjectForConnection(String connection){
		switch (connection) {
[comment find all ConnectionRefernces that are within this instance /]
[for (conRef : ConnectionReference | instance.getAllEnclosingConnectionInstances().connectionReference->select(conr | conr._context = instance))]
	[let contextComponent : ComponentInstance = conRef.source.getContainingComponentInstance()]
		case "[conRef.connection.name/]":
		[comment if the source of this connection is a DataPort of "instance", wa ask its parentBroker for a synchronisation object /]
		[if (contextComponent = instance)]
			[comment a data port only has one incoming connection, if no data aggregation is done /]
			// Ask the parentBroker for the syncObject, as [conRef.source.name/] which is the source feature of [conRef.connection.name/] 
			// is a port of this component and not of a subcomponent. Thus, we must ask the parent component for a syncObject.
			return parentBroker.getSynchronisationObjectForPort("[instance.name/].[conRef.source.name/]");
		[comment if the source component of this connection is a subcomponent, we ask its childbroker for a synchronisation object /]
		[else]
			[comment retrieve the incoming connections for the source port within the child componentInstance /]
			[let incomingConnections : Sequence(ConnectionReference) = contextComponent.getAllEnclosingConnectionInstances().connectionReference->select(conr | (conr._context = contextComponent and conr.destination = conRef.source))]
				[comment its a data port, so it should have at most one incoming connection on which we are asking for the syncObject /]
				[if (incomingConnections->size() = 1)]
			// ask the childBroker for a syncObject, as [conRef.source.name/] which is the source feature of [conRef.connection.name/] 
			// has ingoing connections within [contextComponent.name/] (determined during generation)
			return childBrokers.get("[contextComponent.name/]").getSynchronisationObjectForConnection("[incomingConnections-> first().connection.name/]");
				[comment if there's no connection, we look up the sync Object and if there's none, we create a new syncObject and save it for this connection /]
				[else]
			// Look up the syncObject, as [conRef.source.name/] which is the source feature of [conRef.connection.name/] 
			// has no ingoing connections within [contextComponent.name/] (determined during generation).
			// If no existing syncObject is found, a new one is created and stored for later reuse.
			Object syncOn[conRef.connection.name/] = syncObjects.get("[conRef.connection.name/]");
			if(syncOn[conRef.connection.name/] == null){
				syncOn[conRef.connection.name/] = new Object();
				syncObjects.put("[conRef.connection.name/]", syncOn[conRef.connection.name/]);	
			}
			return syncOn[conRef.connection.name/];
				[/if]
			[/let]
		[/if]
	[/let]
[/for]
		default:
			log.severe("No sync object found for connectionname: " + connection);
			return null;
		}
	}

	@Override
	public Object getSynchronisationObjectForPort(String port){
		switch (port) {
[let classifier : ComponentImplementation = instance.getClassifier()]
	[for (connection : Connection | classifier.getAllConnections())]
		[comment we only need in ports of subcomponents /]
		[let subcomponent : Subcomponent = connection.getTargetComponent()]
			[let dataPort : DataPort = connection.getTargetFeature()]
		case "[subcomponent.name/].[dataPort.name/]":	
			// [dataPort.name/] is the target of [connection.name/]. As data ports have only one ingoing connection 
			// (no modes, no dataaggregation), we ask on [connection.name/] for a syncObject.
			return getSynchronisationObjectForConnection("[connection.name/]");
			[/let]
		[/let]
	[/for]
[/let]
		default:
			log.severe("No sync object found for portname: " + port);
			return null;
		}
	}
}
[/file]
[/template]

[template private getConstructorParameters(instance : ComponentInstance) post (replaceAll('\n', '').trim())]
ConnectionBroker parentBroker, [instance.getClassifier().getClassName()/] component
[if (instance.getClassifier().oclAsType(ComponentImplementation).getAllSubComponents()->size()>0)]
, 
	[for (subcomponent : Subcomponent | instance.getClassifier().oclAsType(ComponentImplementation).getAllSubComponents()) separator (', ')]
[subcomponent.getClassifier().getClassName()/] [subcomponent.name/]
	[/for]
[/if]
[/template]
