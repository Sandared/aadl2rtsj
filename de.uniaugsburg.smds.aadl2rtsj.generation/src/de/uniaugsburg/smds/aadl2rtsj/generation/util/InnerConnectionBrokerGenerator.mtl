[comment encoding = UTF-8 /]
[module InnerConnectionBrokerGenerator('http://aadl.info/AADL/2.0/instance', 'http://aadl.info/AADL/2.0')]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ComponentClassifierHelper /]
[import de::uniaugsburg::smds::aadl2rtsj::generation::services::ComponentInstanceHelper /]
[template public generateInnerConnectionBroker(instance : ComponentInstance)]
[file(instance.getPackageName(false).substitute('.', '/').concat('/').concat(instance.getClassName().concat('ConnectionBroker')).concat('.java') , false, 'UTF-8')]
package [instance.getPackageName(false)/];

import java.util.Map;
import java.util.HashMap;

//########## Classifier Imports ##########
	[comment import all classifiers of this Broker's ComponentImplemntation, but only once for each classifier/]
	[for (classifier : ComponentClassifier | instance.getClassifier().oclAsType(ComponentImplementation).getAllClassifiersForConnectionBroker())]
import [classifier.getPackageName()/].[classifier.getClassName()/];
	[/for]

//########## ConnectionBroker Import ###########
import de.uniaugsburg.smds.aadl2rtsj.generation.util.ConnectionBroker;
import de.uniaugsburg.smds.aadl2rtsj.generation.util.BasicConnectionBroker;

//########## Logger Import ##########
import java.util.logging.Logger;

/**
 * The standard ConnectionBroker to be used by components with inner connections.
 * @author thomas.driessen@informatik.uni-augsburg.de
 */
public class [instance.getClassName()/]ConnectionBroker extends BasicConnectionBroker{

	/**
	 * A logger for logging errors/warnings/etc.
	 */
	private static final Logger log = Logger.getLogger([instance.getClassName()/]ConnectionBroker.class.getName());

	/**
	 * A map of synchronisation Objects. For each subcomponent that is the ultimative source of a connection</br>
	 * where a syncObject is needed (immediate connection), a syncObject is created lazily and stored in this Map.
	 */
	private Map<String, Object> syncObjects = new HashMap<String, Object>();

	/**
	 * Broker to be used when retrieving syncObjects from 'higher' nested components
	 */
	private ConnectionBroker parentBroker;

	/**
	 * Component whose out ports are to be used when forwarding connections to 'higher' nested components
	 */
	private [instance.getClassifier().getClassName()/] component;
	[comment for each subcomponent we have to create an member variable/]
	[if (instance.getClassifier().oclAsType(ComponentImplementation).getAllSubComponents()->size() > 0)]
		[for (subcomponent : Subcomponent | instance.getClassifier().oclAsType(ComponentImplementation).getAllSubComponents())]

	/**
	 * Subcomponent whose in ports are to be used when forwarding connections to 'deeper' nested components
	 */
	private [subcomponent.getClassifier().getClassName()/] [subcomponent.name/];
		[/for]
	[/if]	

	public [instance.getClassName()/]ConnectionBroker([instance.getConstructorParameters()/]){
		this.parentBroker = parentBroker;
		this.component = component;
		[comment for each subcomponent we have to create an Assignment Statement/]
		[if (instance.getClassifier().oclAsType(ComponentImplementation).getAllSubcomponents()->size() > 0)]
			[for (subcomponent : Subcomponent | instance.getClassifier().oclAsType(ComponentImplementation).getAllSubcomponents())]
		this.[subcomponent.name/] = [subcomponent.name/];
			[/for]
		[/if]	
	}

	@Override
	public void sendOnConnection(String connection, Object data){
		switch (connection) {
[let classifier : ComponentImplementation = instance.getClassifier()]
	[for (connection : Connection | classifier.getAllConnections())]
		// [connection.name/]
		case "[connection.name/]":
		[let port : DataPort = connection.getTargetFeature()]
			[let target : Subcomponent = connection.getTargetComponent()]
			[comment if the connection target is a Subcomponent it means we have to use the inPort of this subcomponent, which is declared in it's interface /]
			// [port.name/] is the target feature of [connection.name/] 
			// which is a connection between subcomponents of [instance.getClassifier().getClassName()/], 
			// so call its corresponding in mehtod
			[target.name/].in[port.name.toUpperFirst()/](([port.getClassifier().getClassName()/])data);
			break;
			[elselet target : ComponentImplementation = connection.getTargetComponent()]
			[comment else we send on the outport of this component, which is basically a broadcast/]
			// [port.name/] is the target feature of [connection.name/] 
			// which is a connection from a subcomponent of [instance.getClassifier().getClassName()/] to [instance.getClassifier().getClassName()/] itself, 
			// so call its corresponding out mehtod
			component.out[port.name.toUpperFirst()/](([port.getClassifier().getClassName()/])data);
			break;
			[/let]
		[/let]
	[/for]
[/let]
		default:
			log.warning("No connection to send on found for: " + connection);
			break;
		}
	}
	
	@Override
	public void sendOnPort(String port, Object data){
		switch (port) {
[let classifier : ComponentImplementation = instance.getClassifier()]
	[comment for each subcomponent we search for outgoing dataPorts and create a sendOnConnection(...) method for each connection, that has this dataPort as source /]
	[for (subcomponent : ComponentClassifier | classifier.getAllSubcomponentClassifier())]
		[for (dataPort : DataPort | subcomponent.getAllFeatures()->select(oclIsTypeOf(DataPort)))]
			[if (dataPort.isOutgoing())]
		[comment we use the port name concatenated with the subcomponent name, because in the contex of the parent object a subcomponents port name might not be unique /]
		case "[subcomponent.name/].[dataPort.name/]":
			// send on all connections within [instance.getClassifier().getClassName()/] that have [dataPort.name/] as source
				[for (connection : Connection | classifier.getAllConnections())]
					[if (connection.getSourceFeature() = dataPort)]
			sendOnConnection("[connection.name/]", data);
					[/if]
				[/for]	
			break;
			[/if]
		[/for]
	[/for]
[/let]
		default:
			log.warning("No port to send on found for: " + port);
			break;
		}
	}

	@Override
	public Object getSynchronisationObjectForConnection(String connection){

		switch (connection) {
[let classifier : ComponentImplementation = instance.getClassifier()]
	[for (connection : Connection | classifier.getAllConnections())]
		// [connection.name/]
		case "[connection.name/]":
		[comment if the source component of this connection is a subcomponent, wa ask its childbroker for a synchronisation object /]
		[let subcomponent : Subcomponent = connection.getSourceComponent()]
			[comment we assume it's an Implementation and not a Type, otherwise we couldn't determine the connection to send on /]
			[let sourceComp : ComponentImplementation = subcomponent.getClassifier()]
				[let dataPort : DataPort = connection.getSourceFeature()]
					[comment its a data port, so it should have at most one incoming connection on which we are asking for the syncObject /]
					[if (dataPort.getInternalIncomingConnections(sourceComp) -> size() = 1)]
			// ask the childBroker for a syncObject, as [dataPort.name/] which is the source feature of [connection.name/] 
			// has ingoing connections within [subcomponent.name/] (determined during generation)
			return childBrokers.get("[subcomponent.name/]").getSynchronisationObjectForConnection("[dataPort.getInternalIncomingConnections(sourceComp)-> first().name/]");
					[comment if there's no connection, we look up the sync Object and if there's none, we create a new syncObject and save it for this connection /]
					[elseif (dataPort.getInternalIncomingConnections(sourceComp) -> size() = 0)]
			// Look up the syncObject, as [dataPort.name/] which is the source feature of [connection.name/] 
			// has no ingoing connections within [subcomponent.name/] (determined during generation).
			// If no syncObject is found, a new one is created and stored for later reuse.
			Object syncOn[connection.name/] = syncObjects.get("[connection.name/]");
			if(syncOn[connection.name/] == null){
				syncOn[connection.name/] = new Object();
				syncObjects.put("[connection.name/]", syncOn[connection.name/]);	
			}
			return syncOn[connection.name/];
					[/if]
				[/let]
			[/let]
		[comment if the source component of this connection is a ComponentImplmentation, wa ask its parentBroker for a synchronisation object, as it's a port of the component itself /]
		[elselet sourceComp : ComponentImplementation = connection.getSourceComponent()]
			[let dataPort : DataPort = connection.getSourceFeature()]
			[comment a data port only has one incoming connection, if no data aggregation is done /]
			// Ask the parentBroker for the syncObject, as [dataPort.name/] which is the source feature of [connection.name/] 
			// is a port of this component and not of a subcomponent. Thus, we must ask the parent component for a syncObject.
			return parentBroker.getSynchronisationObjectForPort("[instance.name/].[dataPort.name/]");
			[/let]
		[/let]		
	[/for]
[/let]
		default:
			log.warning("No sync object found for connectionname: " + connection);
			//TODO: Exception?
			return null;
		}
	}

	@Override
	public Object getSynchronisationObjectForPort(String port){
		switch (port) {
[let classifier : ComponentImplementation = instance.getClassifier()]
	[for (connection : Connection | classifier.getAllConnections())]
		[let subcomponent : Subcomponent = connection.getTargetComponent()]
			[let dataPort : DataPort = connection.getTargetFeature()]
		case "[subcomponent.name/].[dataPort.name/]":	
			// [dataPort.name/] is the target of [connection.name/]. As data ports have only one ingoing connection 
			// (no modes, no dataaggregation), we ask on [connection.name/] for a syncObject.
			return getSynchronisationObjectForConnection("[connection.name/]");
			[/let]
		[/let]
	[/for]
[/let]
		default:
			log.warning("No sync object found for portname: " + port);
			//TODO: Exception Handling?
			return null;
		}
	}
}
[/file]
[/template]

[template private getConstructorParameters(instance : ComponentInstance) post (replaceAll('\n', '').trim())]
ConnectionBroker parentBroker, [instance.getClassifier().getClassName()/] component
[if (instance.getClassifier().oclAsType(ComponentImplementation).getAllSubComponents()->size()>0)]
, 
	[for (subcomponent : Subcomponent | instance.getClassifier().oclAsType(ComponentImplementation).getAllSubComponents()) separator (', ')]
[subcomponent.getClassifier().getClassName()/] [subcomponent.name/]
	[/for]
[/if]
[/template]
